esphome:
  name: l0r430t-lrtx
  friendly_name: LRTX
  comment: LoRaBot Transmit Node - Central control hub for long-range radio communication
  project:
    name: "ManRiver.L0R430T"
    version: "1.0.0"  
  platformio_options:
    build_flags: 
      # Hardware-specific definitions for Heltec WiFi LoRa 32 V3
      # Reference: https://github.com/lucaskatayama/platform-espressif32/blob/develop/boards/heltec_wifi_lora_32_V3.json
      - "-DARDUINO_heltec_wifi_lora_32_V3"              # Board identifier for proper pin mapping
      - '-DCORE_DEBUG_LEVEL=0'                          # Debug levels: 0=None, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Verbose
      - '-DCONFIG_ARDUHAL_LOG_COLORS'                   # Enable colored logging output for easier debugging
      - '-DARDUINO_USB_CDC_ON_BOOT=1'                   # CRITICAL: Enables USB-CDC on boot for Windows COM port recognition
                                                         # Required for xinputToL0R430T.py serial communication
                                                         # Tested on Windows 11 (Lenovo Legion GO)
      - '-DARDUINO_RUNNING_CORE=1'                      # Pin Arduino framework to CPU core 1 for stability
      - '-DARDUINO_EVENT_RUNNING_CORE=1'                # Pin event handling to CPU core 1
      
      # Commented USB identifiers (kept for reference)
      # - "-DUSB_VID=0x303A"                            # Custom USB Vendor ID
      # - "-DUSB_PID=0x1001"                            # Custom USB Product ID  
      # - "-DUSB_PRODUCT='l0r430t_LRTX'"                # Custom USB product name
      # - "-DUSB_MANUFACTURER='ManRiver_L0R430T'"       # Custom USB manufacturer name
      
    # Flash and memory configuration for 8MB ESP32-S3
    board_build.partitions: 'default_8MB.csv'           # Custom partition table for 8MB flash
    board_build.f_flash: 80000000L                       # Flash frequency: 80MHz (stable for most conditions)
    
    # CPU frequency optimization (performance vs power consumption)
    # board_build.f_cpu: 240000000L                     # Maximum performance (240MHz) - high power consumption
    # board_build.f_cpu: 220000000L                     # High performance (220MHz) - tested stable
    board_build.f_cpu: 200000000L                        # Balanced performance (200MHz) - tested stable, recommended
    # board_build.f_cpu: 160000000L                     # Power saving (160MHz) - insufficient for real-time processing
    
    # Memory and upload configuration  
    board_upload.maximum_size: '8388608'                 # 8MB = 8 * 1024 * 1024 bytes
    board_upload.maximum_ram_size: '327680'              # 320KB = 320 * 1024 bytes (ESP32-S3 SRAM)
    board_upload.speed: '460800'                         # Upload baud rate (matches UART communication speed)
  on_boot:
    # ========================================================================
    # CRITICAL HARDWARE INITIALIZATION SEQUENCE
    # ========================================================================
    # Priority 1000: Execute first during boot process (highest priority)
    # This sequence fixes OLED display initialization issues on Heltec V3
    # Reference: https://www.reddit.com/r/Esphome/comments/1i3p17x/anybody_got_the_display_on_a_heltec_wifi_lora_32/
    - priority: 1000 
      then:
        - lambda: |-
            // VEXT (GPIO36) controls power to external peripherals including OLED display
            // This black voodoo initialization sequence is required for reliable OLED startup
            pinMode(36, OUTPUT);           // Configure VEXT as output pin
            digitalWrite(36, LOW);         // Enable power to OLED (LOW = enabled on Heltec V3)
            delay(100);                    // 100ms delay as recommended by Heltec documentation
       
    # Priority -100: Execute after all components are initialized (low priority)
    # This sequence configures the system after hardware initialization is complete
    - priority: -100
      then:  
        # Temporarily disable BLE RSSI sensor to prevent log spam during startup
        - component.suspend: ble_hid_rssi
        
        # Visual startup sequence: Fast pulse indicates system ready
        - light.turn_on:
            id: lora_led
            effect: FastPulseHi
            
        # Set OLED display contrast for optimal visibility
        # Range: 0-255, where 50 â‰ˆ 20% brightness for battery conservation
        - lambda: |-
            id(my_display).set_contrast(50);
            
        # Startup timing sequence
        - delay: 5s                        # 5-second visual indicator period
        - light.turn_off: lora_led         # Turn off startup indicator
        - delay: 5s                        # 5-second settling period
        
        # Initiate LoRa ping test to verify radio functionality
        - button.press: lora_ping
# ============================================================================
# GPIO PIN ASSIGNMENTS AND HARDWARE MAPPING (Heltec WiFi LoRa 32 V3)
# ============================================================================
# Commented substitutions kept for reference - these define the hardware layout
# 
# Power Management:
# - vext_ctrl_heltecv3: GPIO36    # VEXT power control (OLED, sensors)
# - batt_div_heltecv3: GPIO37     # Battery voltage divider input
# - adc_heltecv3: GPIO1           # ADC input for battery monitoring
# 
# Communication Interfaces:
# - i2c_sda: GPIO17               # I2C Data line (OLED display)
# - i2c_scl: GPIO18               # I2C Clock line (OLED display)  
# - usbc_uart_tx: GPIO43          # USB-C UART transmit (to PC)
# - usbc_uart_rx: GPIO44          # USB-C UART receive (from PC)
#
# Display and User Interface:
# - display_reset_pin: GPIO21     # OLED display reset control
# - mcu_led: GPIO35               # Onboard status LED
# - mcu_button_heltecv3: GPIO0    # Onboard user button
#
# Bluetooth Configuration:
# - ble_hid_client1: !secret xboxblue  # Xbox controller MAC address (stored in secrets)
#
# substitutions:
  # vext_ctrl_heltecv3: GPIO36
  # batt_div_heltecv3: GPIO37
  # ble_hid_client1: !secret xboxblue
  # i2c_sda: GPIO17
  # i2c_scl: GPIO18
  # display_reset_pin: GPIO21
  # mcu_led: GPIO35
  # adc_heltecv3: GPIO1
  # mcu_button_heltecv3: GPIO0
  # usbc_uart_tx: GPIO43
  # usbc_uart_rx: GPIO44
                             
esp32:
  # ========================================================================
  # ESP32-S3 HARDWARE CONFIGURATION
  # ========================================================================
  board: heltec_wifi_lora_32_V3              # Specific board definition for proper peripheral mapping
  # Alternative board option (commented): esp32-s3-devkitc-1
  flash_size: 8MB                            # Total flash memory available (8 megabytes)
  variant: esp32s3                           # ESP32-S3 chip variant (dual-core, WiFi + BLE)
  framework:
    type: arduino                            # Arduino framework for familiar development environment
    version: latest                          # Use latest stable Arduino framework version
    platform_version: 6.11.0               # PlatformIO ESP32 platform version
                                            # Reference: https://github.com/platformio/platform-espressif32/releases

# ========================================================================
# EXTERNAL COMPONENT INTEGRATION
# ========================================================================
external_components:
  # Local components stored in 'components' directory
  # These provide custom functionality not available in standard ESPHome
  - source:
      type: local
      path: components                       # Local directory containing custom components
      
  # Alternative external components (commented for reference):
  # GitHub-hosted SX1262 LoRa driver
  # - source: github://christianhubmann/esphome_component_sx1262@main 
  #   components: [ sx1262 ]
  #
  # GitHub-hosted BLE HID client component  
  # - source: github://fsievers22/esphome-ble-remote@master
  #   components: [ ble_client_hid ]    


# ========================================================================
# LOGGING CONFIGURATION
# ========================================================================
logger:
  id: logger_id
  level: DEBUG                               # Global log level for development and troubleshooting
  initial_level: DEBUG                       # Log level during boot sequence
  # deassert_rts_dtr: True                   # Uncomment if having serial communication issues
  baud_rate: 0                              # Disable UART logging to free up pins for data communication
  
  # Fine-grained logging control to reduce noise from verbose components
  # WARN level reduces log spam while maintaining error visibility
  logs:
    script: WARN                             # Script execution logs (automation sequences)
    ble_client_hid: WARN                    # BLE HID client communication logs
    esp32_ble_client: WARN                  # ESP32 BLE client stack logs
    esp32_ble_tracker: WARN                 # BLE device scanning and tracking logs
    sensor: WARN                            # Sensor reading and update logs
    hid_parser: WARN                        # HID input parsing logs  
    number: WARN                            # Number input component logs
    text_sensor: WARN                       # Text sensor update logs
    uart: WARN                              # UART communication logs (high frequency)
    sx1262: WARN                            # LoRa radio driver logs
    light: WARN                             # LED control logs
    ledc: WARN                              # LED PWM controller logs

# ========================================================================
# WEB SERVER AND USER INTERFACE CONFIGURATION
# ========================================================================
web_server:
  port: 80                                   # Standard HTTP port for web interface
  version: 3                                 # ESPHome web server version 3 (latest features)
  local: True                                # Enable local-only access (no external internet required)
  
  # Organized grouping system for logical arrangement of controls and sensors
  # Lower sorting_weight values appear first in the web interface
  sorting_groups:
    - id: sorting_group_robotcontrol
      name: "R030tC0ntr0l"                   # Robot control interfaces (servos, motors, etc.)
      sorting_weight: 10                     # Highest priority - primary controls
      
    - id: sorting_group_bluetooth
      name: "Bluetooth"                      # BLE controller status and settings
      sorting_weight: 20                     # Second priority - input devices
      
    - id: sorting_group_longrangeradio
      name: "LongRangeRadio"                 # LoRa radio status and configuration  
      sorting_weight: 30                     # Third priority - communication systems
      
    - id: sorting_group_mcu
      name: "MCU"                            # Microcontroller status (temperature, battery, etc.)
      sorting_weight: 40                     # Fourth priority - system health   

# ========================================================================
# BLUETOOTH LOW ENERGY (BLE) CONFIGURATION
# ========================================================================
# Three-component BLE system for Xbox controller integration:
# 1. esp32_ble_tracker: Scans for and discovers BLE devices
# 2. ble_client: Manages connection to specific device (Xbox controller)  
# 3. ble_client_hid: Handles HID (Human Interface Device) protocol parsing

esp32_ble_tracker: 
  # BLE device scanning configuration
  scan_parameters:
    continuous: False                        # Disable continuous scanning to reduce power consumption
                                            # Scanning only occurs during connection attempts
  
ble_client_hid: 
  # HID client configuration for Xbox controller input parsing
  - id: ble_client_hid_1                    # Unique identifier for this HID client instance
    ble_client_id: ble_client_1             # Links to the BLE client connection below
      
ble_client: 
  # BLE client connection management for Xbox controller
  - id: ble_client_1                        # Unique identifier for this BLE client
    mac_address: !secret xboxblue           # Xbox controller MAC address (stored in secrets.yaml)
    auto_connect: true                      # Automatically attempt connection when controller is available
    
    # Connection established callback sequence
    on_connect: 
      then:
        # Update connection status indicator
        - lambda: !lambda |-
           id(ble_hid_cx1).publish_state(true);  
           
        # Resume RSSI monitoring (suspended during startup to prevent log spam)
        - component.resume: ble_hid_rssi
        
        # Allow 10 seconds for connection stabilization, then stop scanning to save power
        - delay: 10s
        - esp32_ble_tracker.stop_scan           
        
    # Connection lost callback sequence    
    on_disconnect: 
      then:
        # Suspend RSSI monitoring to prevent error logs
        - component.suspend: ble_hid_rssi
        - delay: 500ms                       # Brief delay for clean disconnection
        
        # Update connection status indicator    
        - lambda: !lambda |-
           id(ble_hid_cx1).publish_state(false);         
           
        # Restart scanning if BLE is still enabled (user hasn't disabled it)
        - if:
            condition:
              switch.is_on:
                id: ble_hid_sw               # Check if BLE switch is still enabled
            then:
              # Resume continuous scanning to find controller again
              - esp32_ble_tracker.start_scan:
                  continuous: true 
       

# ========================================================================
# CONNECTIVITY AND COMMUNICATION INTERFACES
# ========================================================================

# ESPHome API for Home Assistant integration and OTA updates
api: 
  # NOTE: Currently required by BLE HID component as a dependency
  # TODO: Request from component maintainer to make API optional for standalone LoRa applications
  # In our use case, API is redundant since we parse directly to LoRa radio for wireless control
  encryption:
    key: !secret api                        # API encryption key (stored in secrets.yaml)
  reboot_timeout: 0s                       # Disable automatic reboot on API disconnect

# Over-The-Air (OTA) update configuration
ota:
  - platform: esphome
    password: !secret ota                  # OTA update password (stored in secrets.yaml)

# WiFi network configuration
wifi:
  ssid: !secret wifi_ssid                  # WiFi network name (stored in secrets.yaml)
  password: !secret wifi_password4         # WiFi password (stored in secrets.yaml)
  domain: !secret domain                   # Local domain name (stored in secrets.yaml)
  fast_connect: on                         # Skip scanning, connect to last known network faster
  # power_save_mode: none                  # Uncomment to disable power saving for minimum latency
  ap: {}                                   # Enable fallback access point if WiFi fails

# Captive portal for WiFi configuration when in AP mode
captive_portal:

# ========================================================================
# I2C BUS CONFIGURATION (OLED Display Communication)
# ========================================================================
i2c:
  - id: bus_a                              # I2C bus identifier
    sda: GPIO17                            # Serial Data line (Heltec V3 standard)
    scl: GPIO18                            # Serial Clock line (Heltec V3 standard)  
    scan: True                             # Enable I2C device scanning during startup (helpful for debugging)
    frequency: 400kHz                      # I2C clock frequency (400kHz = fast mode, good for OLED)
 
# ========================================================================
# UART COMMUNICATION SYSTEM (PC Serial Input Processing)
# ========================================================================
uart:
  - id: usb_uart                           # UART identifier for USB-C communication
    # Hardware: Heltec V3 integrated CP2102 USB-to-serial converter chip
    tx_pin: GPIO43                         # UART transmit pin (ESP32 â†’ PC)
    rx_pin: GPIO44                         # UART receive pin (PC â†’ ESP32)
    baud_rate: 460800                      # High-speed communication (tested stable with xinputToL0R430T.py)
    rx_buffer_size: 0                      # Zero buffer for minimum latency (real-time processing)
    
    # Real-time packet processing and LoRa forwarding system
    debug:
      direction: BOTH                      # Monitor both TX and RX for debugging
      dummy_receiver: true                 # Enable packet capture without interfering with processing
      after:
        delimiter: "\n"                    # Process packets after newline delimiter
        
      # ====================================================================
      # BINARY PACKET PROCESSING ENGINE
      # ====================================================================  
      # This sequence handles incoming binary packets from xinputToL0R430T.py
      # and forwards them via LoRa radio to remote nodes
      sequence: 
        - lambda: |-
            // ================================================================
            // PACKET PROCESSING AND LORA FORWARDING SYSTEM
            // ================================================================
            // Input: Binary packets from xinputToL0R430T.py via USB-C serial
            // Output: ASCII/Binary packets via LoRa radio to LRRX node
            //
            // Packet Formats:
            // AXIS:   [0x41, axis_id, float32_value, 0x0A] (7 bytes total)
            // BUTTON: [0x42, button_id, pressed_state, 0x0A] (4 bytes total)
            
            // Start UART host processing script if not already running
            if (!id(uart_host_script).is_running()) {
                id(uart_host_script).execute(); 
            }               
            
            // ============================================================
            // AXIS PACKET PROCESSING (7-byte packets)
            // ============================================================
            // Format: [0x41][axis_id][float32_value][0x0A]
            // Only process if LoRa radio is enabled (lora_rf switch = true)
            if (bytes.size() == 7 && bytes[0] == 0x41 && id(lora_rf).state == true) {
              uint8_t axis_id = bytes[1];                    // Extract axis identifier (1-6)
              
              // ========================================================
              // IEEE 754 FLOAT32 EXTRACTION
              // ========================================================
              // Extract 32-bit float from bytes[2-5] using memory copy
              // This preserves the exact floating-point representation
              // from the PC-side xinput processing
              float value;
              memcpy(&value, &bytes[2], 4);                  // Copy 4 bytes to float variable
              
              // ========================================================
              // ASCII PACKET GENERATION FOR LORA TRANSMISSION
              // ========================================================
              // Convert to ASCII format "A:axis_id:value" for robust LoRa transmission
              // ASCII is more reliable than binary over LoRa due to error characteristics
              char buf[10];                                  // Buffer for ASCII packet (max 10 chars)
              snprintf(buf, sizeof(buf), "A:%d:%.3f", axis_id, value);  // Format: "A:1:0.500"
              std::string msg(buf);                          // Convert to string for transmission
              
              // ========================================================
              // AXIS-SPECIFIC PROCESSING AND HUD FEEDBACK
              // ========================================================
              // Process each axis type and update corresponding HUD displays
              
              if (axis_id == 0x01) {                         // LEFT TRIGGER (Reverse/Brake)
                // Update reverse control HUD with current value (0.0 - 1.0 range)
                auto call = id(hud_reverse).make_call();
                call.set_value(value);
                call.perform();                   
                // Transmit "A:1:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));              
                
              } else if (axis_id == 0x02) {                  // RIGHT TRIGGER (Forward Throttle)
                // Update throttle control HUD with current value (0.0 - 1.0 range)
                auto call = id(hud_throttle).make_call();
                call.set_value(value);
                call.perform();                                            
                // Transmit "A:2:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));              
                
              } else if (axis_id == 0x03) {                  // LEFT THUMBSTICK X (Steering)
                // Update servo control HUD with current value (-2.0 - +2.0 range, 2x multiplier applied)
                auto call = id(hud_servo).make_call();
                call.set_value(value);
                call.perform();                                            
                // Transmit "A:3:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));              
                
              } else if (axis_id == 0x04) {                  // LEFT THUMBSTICK Y (Forward/Back)
                // No local HUD update for this axis (pass-through only)
                // Transmit "A:4:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));                          
                
              } else if (axis_id == 0x05) {                  // RIGHT THUMBSTICK X (Camera Pan/Turret)
                // Update servo control HUD (shared with steering for visual feedback)
                auto call = id(hud_servo).make_call();
                call.set_value(value);
                call.perform();                 
                // Transmit "A:5:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));              
                
              } else if (axis_id == 0x06) {                  // RIGHT THUMBSTICK Y (Camera Tilt/Elevation)
                // No local HUD update for this axis (pass-through only)
                // Transmit "A:6:value" via LoRa
                id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));              
              }                         
              
            // ============================================================
            // BUTTON PACKET PROCESSING (4-byte packets)
            // ============================================================
            // Format: [0x42][button_id][pressed_state][0x0A]
            // Only process if LoRa radio is enabled (lora_rf switch = true)
            } else if (bytes.size() == 4 && bytes[0] == 0x42 && id(lora_rf).state == true) {
              uint8_t button = bytes[1];                     // Button identifier (0-17, XInput mapping)
              uint8_t pressed = bytes[2];                    // Button state: 1=pressed, 0=released
              
              // ========================================================
              // BINARY PACKET GENERATION FOR LORA TRANSMISSION
              // ========================================================
              // Button packets use binary format for efficiency
              // Each packet contains only button_id and state (2 bytes total)
              std::vector<uint8_t> packet;
              packet.push_back(button);                      // Add button identifier
              packet.push_back(pressed);                     // Add button state
              
              // Execute LoRa transmission script and send binary packet
              id(lora_tx_script).execute(); 
              id(lora)->send_packet(packet);
            }     
        
        # - lambda: |-
        #     //Forward AXIS packets in ASCII
        #     //UARTDebug::log_string(direction, bytes);
        #     if (!id(uart_host_script).is_running()) {
        #         id(uart_host_script).execute(); 
        #     }               
        #     if (bytes.size() == 7 && bytes[0] == 0x41 && id(lora_rf).state == true) {
        #       uint8_t axis_id = bytes[1];
        #       float value;
        #       memcpy(&value, &bytes[2], 4);
        #       char buf[10];
        #       snprintf(buf, sizeof(buf), "A:%d:%.3f", axis_id, value);
        #       std::string msg(buf);              
        #       if (!id(lora_tx_script).is_running()) {
        #           id(lora_tx_script).execute(); 
        #       }                  
        #       // Send directly to LoRa
        #       id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));
        #     } else if (bytes.size() == 4 && bytes[0] == 0x42 && id(lora_rf).state == true) {
        #       //Forward Button packets in Binary
        #       uint8_t button = bytes[1];
        #       uint8_t pressed = bytes[2];
        #       std::vector<uint8_t> packet;
        #       packet.push_back(button);
        #       packet.push_back(pressed);
        #       // Send directly to LoRa
        #       id(lora_tx_script).execute(); 
        #       id(lora)->send_packet(packet);
        #     }        
        # - lambda: |-
        #     // Forward AXIS packets in Binary, but I couldn't make it work.                   
        #     //received as hex to reencode to binary before sending to Lora.
        #     if (bytes.size() == 7 && bytes[0] == 0x41) {
        #       uint8_t axis_id = bytes[1];
        #       if (axis_id == 0x01 || axis_id == 0x02 || axis_id == 0x03 || axis_id == 0x04 || axis_id == 0x05 || axis_id == 0x06) { // Don't send for A:4 and A:6
        #         float value;
        #         memcpy(&value, &bytes[2], 4);
        #         std::vector<uint8_t> packet;
        #         packet.push_back(axis_id);
        #         uint8_t *val_bytes = reinterpret_cast<uint8_t*>(&value);
        #         packet.insert(packet.end(), val_bytes, val_bytes + sizeof(float));
        #         id(lora_tx_script).execute();
        #         id(lora)->send_packet(packet);
        #       }
        #     } else if (bytes.size() == 4 && bytes[0] == 0x42) {
        #       uint8_t button = bytes[1];
        #       uint8_t pressed = bytes[2];
        #       std::vector<uint8_t> packet;
        #       packet.push_back(button);
        #       packet.push_back(pressed);
        #       id(lora_tx_script).execute();
        #       id(lora)->send_packet(packet);
        #     }
              
        # - lambda: |-
        #     // Forward AXIS packets in ASCII
        #     //UARTDebug::log_string(direction, bytes);
        #     if (bytes.size() == 7 && bytes[0] == 0x41) {
        #       uint8_t axis_id = bytes[1];
        #       float value;
        #       memcpy(&value, &bytes[2], 4);
        #       char buf[32];
        #       snprintf(buf, sizeof(buf), "A:%d:%.3f", axis_id, value);
        #       // Send directly to LoRa
        #       std::string msg(buf);
        #       id(lora_tx_script).execute();
        #       id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));
        #     } else if (bytes.size() == 4 && bytes[0] == 0x42) {
        #       //ASCII
        #       uint8_t button = bytes[1];
        #       uint8_t pressed = bytes[2];
        #       char buf[16];
        #       snprintf(buf, sizeof(buf), "B:%d:%d", button, pressed);
        #       std::string msg(buf);
        #       id(lora_tx_script).execute();
        #       id(lora)->send_packet(std::vector<uint8_t>(msg.begin(), msg.end()));
        #     }
# ========================================================================
# SENSOR CONFIGURATION AND INPUT PROCESSING
# ========================================================================
sensor:
  # ======================================================================
  # BLE HID SENSOR (Xbox Controller Input Processing)
  # ======================================================================
  - platform: ble_client_hid 
    # NOTE: ble_client_hid component has X and Y axes inverted from standard
    # This is left as-is for continuity with existing codebase
    type: last_event_value                 # Process the most recent HID event value
    ble_client_hid_id: ble_client_hid_1   # Links to BLE HID client configuration above
    id: ble_hid_value                     # Sensor identifier for referencing in automations
    icon: mdi:microsoft-xbox-controller   # Web UI icon
    web_server:
      sorting_group_id: sorting_group_bluetooth    # Group in Bluetooth section of web UI
      
    # ====================================================================
    # HEARTBEAT FILTER FOR LORA TRANSMISSION PACING
    # ====================================================================
    # This filter controls the maximum rate of LoRa transmissions
    # 0.04s = 25Hz update rate, optimized for LoRa radio capabilities
    # Creates consistent packet stream for low-latency remote control
    filters:
      - heartbeat: 0.04s                 # 25Hz transmission rate (40ms intervals)
                                         # This is the "LoRa magic number" for optimal performance
                                         # Too fast: radio overload, packet loss
                                         # Too slow: poor responsiveness
    
    # ====================================================================
    # BLE HID VALUE PROCESSING AND LORA TRANSMISSION
    # ====================================================================                                     
    on_value:    
      - if:
          # ================================================================
          # INTELLIGENT FILTERING SYSTEM
          # ================================================================
          # Only process and transmit if ALL conditions are met:
          # 1. LoRa radio is enabled (lora_rf switch = true)
          # 2. HID usage is NOT filtered axis types (prevents spam)
          # 3. HID usage is NOT local-only functions
          condition: 
            - lambda: |-
                auto usage = id(ble_hid_usage).state;
                // Filter out problematic axis types that cause transmission spam:
                // "Rz": Rotation Z-axis (often noisy)
                // "Y": Y-axis (conflicts with X-axis processing)  
                // "9_13": Specific button mapping (processed elsewhere)
                // "Record": Local function only (WiFi control, not transmitted)
                return id(lora_rf).state == true && usage != "Rz" && usage != "Y" && usage != "9_13" && usage != "Record";          
          then:
            # ==============================================================
            # LORA PACKET TRANSMISSION SYSTEM
            # ==============================================================
            - sx1262.send_packet:
                # blocking: true                    # Uncomment for synchronous transmission (higher latency)
                data: !lambda |-
                  // ========================================================
                  // STATIC VALUE CACHING FOR FLOOD PREVENTION
                  // ========================================================
                  // These static variables maintain the last transmitted value
                  // for each axis to prevent redundant LoRa transmissions
                  // This significantly reduces radio traffic and improves battery life
                  static float last_2_196 = 0;      // Right trigger last value
                  static float last_2_197 = 0;      // Left trigger last value  
                  static float last_x = 0;          // Left thumbstick X last value
                  static float last_z = 0;          // Right thumbstick X last value
                  
                  // ========================================================
                  // LEFT THUMBSTICK X-AXIS PROCESSING (Steering Control)
                  // ========================================================
                  if (id(ble_hid_usage).state == "X") {
                    // MATHEMATICAL CONVERSION:
                    // Raw HID value: 0 to 65535 (16-bit unsigned integer)
                    // Conversion formula: ((x - 32767.8) / 32768) * 1
                    // This converts to normalized range: -1.0 to +1.0
                    // 32767.8 = midpoint offset for accurate centering
                    // 32768 = half of full range for normalization
                    float v = ((x-32767.8)/32768)*1;
                    
                    // THRESHOLD FILTERING:
                    // Only transmit if change >= 0.3f (30% of full range)
                    // This prevents noise and micro-movements from flooding LoRa
                    if (std::abs(v - last_x) >= 0.3f) {
                      last_x = v;                    // Update cached value
                      
                      // ASCII packet generation for LoRa transmission
                      char buf[10];
                      snprintf(buf, sizeof(buf), "A:3:%.3f", v);  // Format: "A:3:value"
                      
                      // BINARY PACKET GENERATION (Alternative format)
                      // Create optimized binary packet structure
                      std::vector<uint8_t> packet;
                      uint8_t sensor_id = 0x03;      // Steering axis identifier
                      float value = v;               // Normalized steering value
                      packet.push_back(sensor_id);   // Add axis ID to packet
                      
                      // IEEE 754 float32 serialization
                      // Convert float to byte array for transmission
                      uint8_t *val_bytes = reinterpret_cast<uint8_t*>(&value);
                      packet.insert(packet.end(), val_bytes, val_bytes + sizeof(float));
                      
                      // LOCAL HUD FEEDBACK
                      // Update steering display on OLED for immediate visual feedback
                      auto call = id(hud_servo).make_call();
                      call.set_value(v);
                      call.perform();                      
                      return packet;                 // Transmit binary packet via LoRa
                    }
                    
                  // ========================================================
                  // RIGHT THUMBSTICK X-AXIS PROCESSING (Camera Pan/Turret)
                  // ========================================================  
                  } else if (id(ble_hid_usage).state == "Z") {
                    // Same mathematical conversion as left stick
                    float v = ((x-32767.8)/32768)*1;
                    
                    // Same threshold filtering (0.3f = 30% change required)
                    if (std::abs(v - last_z) >= 0.3f) {
                      last_z = v;                    // Update cached value
                      
                      // ASCII packet generation  
                      char buf[10];
                      snprintf(buf, sizeof(buf), "A:5:%.3f", v);  // Format: "A:5:value"
                      
                      // Binary packet generation for camera pan control
                      std::vector<uint8_t> packet;
                      uint8_t sensor_id = 0x05;      // Camera pan axis identifier
                      float value = v;               // Normalized pan value
                      packet.push_back(sensor_id);
                      
                      // Float serialization
                      uint8_t *val_bytes = reinterpret_cast<uint8_t*>(&value);
                      packet.insert(packet.end(), val_bytes, val_bytes + sizeof(float));
                      
                      // Update camera control HUD display
                      auto call = id(hud_servo).make_call();
                      call.set_value(v);
                      call.perform();                       
                      return packet;
                    }
                    
                  // ========================================================
                  // RIGHT TRIGGER PROCESSING (Forward Throttle)
                  // ========================================================
                  } else if (id(ble_hid_usage).state == "2_196") {
                    // TRIGGER MATHEMATICAL CONVERSION:
                    // Raw HID value: 0 to 1023 (10-bit precision for triggers)
                    // Conversion formula: (x / 1023.0) * 1.0
                    // This converts to normalized range: 0.0 to 1.0 (unidirectional)
                    float v = (x / 1023.0) * 1.0;
                    
                    // HIGHER THRESHOLD FOR TRIGGERS:
                    // 0.7f threshold (70% change) reduces trigger noise and spam
                    // Triggers are more sensitive to small movements than sticks
                    if (std::abs(v - last_2_196) >= 0.7f) {
                      last_2_196 = v;               // Update cached value
                      
                      // ASCII packet generation
                      char buf[8];
                      snprintf(buf, sizeof(buf), "A:2:%.3f", v);  // Format: "A:2:value"
                      
                      // Binary packet generation for throttle control
                      std::vector<uint8_t> packet;
                      uint8_t sensor_id = 0x02;      // Throttle axis identifier
                      float value = v;               // Normalized throttle value (0.0-1.0)
                      packet.push_back(sensor_id);
                      
                      // Float serialization
                      uint8_t *val_bytes = reinterpret_cast<uint8_t*>(&value);
                      packet.insert(packet.end(), val_bytes, val_bytes + sizeof(float));
                      
                      // Update throttle HUD display
                      auto call = id(hud_throttle).make_call();
                      call.set_value(v);
                      call.perform();                       
                      return packet;
                    }
                    
                  // ========================================================
                  // LEFT TRIGGER PROCESSING (Reverse/Brake Control)
                  // ========================================================
                  } else if (id(ble_hid_usage).state == "2_197") {
                    // Same trigger conversion as right trigger
                    float v = (x / 1023.0) * 1.0;
                    
                    // Same high threshold for noise reduction
                    if (std::abs(v - last_2_197) >= 0.7f) {
                      last_2_197 = v;               // Update cached value
                      
                      // ASCII packet generation
                      char buf[8];
                      snprintf(buf, sizeof(buf), "A:1:%.3f", v);  // Format: "A:1:value"
                      
                      // Binary packet generation for reverse control
                      std::vector<uint8_t> packet;
                      uint8_t sensor_id = 0x01; // example for servo
                      float value = v; // your sensor value
                      packet.push_back(sensor_id);
                      uint8_t *val_bytes = reinterpret_cast<uint8_t*>(&value);
                      packet.insert(packet.end(), val_bytes, val_bytes + sizeof(float));
                      // Feedback to HUDs
                      auto call = id(hud_reverse).make_call();
                      call.set_value(v);
                      call.perform();                                             
                      return packet;
                    }
                  //Record button Not pushed to LORA, instead is local function to disable WIFI.
                  //} else if (id(ble_hid_usage).state == "Record") {
                  //  std::vector<uint8_t> packet;
                  //  packet.push_back(17); // Record button ID
                  //  packet.push_back(static_cast<uint8_t>(x));
                  //  return packet;                  
                  } else if (id(ble_hid_usage).state == "9_14") {
                    std::vector<uint8_t> packet;
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_15") {
                    std::vector<uint8_t> packet;
                    packet.push_back(7); // Right Stick
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_7") {
                    std::vector<uint8_t> packet;
                    packet.push_back(8); // LB
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_8") {
                    std::vector<uint8_t> packet;
                    packet.push_back(9); // RB
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_11") {
                    std::vector<uint8_t> packet;
                    packet.push_back(4); // Back
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_12") {
                    std::vector<uint8_t> packet;
                    packet.push_back(5); // Start
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_1") {
                    std::vector<uint8_t> packet;
                    packet.push_back(12); // A
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_2") {
                    std::vector<uint8_t> packet;
                    packet.push_back(13); // B
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_4") {
                    std::vector<uint8_t> packet;
                    packet.push_back(14); // X
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "9_5") {
                    std::vector<uint8_t> packet;
                    packet.push_back(15); // Y
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  } else if (id(ble_hid_usage).state == "Hat Switch") {
                    std::vector<uint8_t> packet;
                    packet.push_back(16); // Hat Switch
                    packet.push_back(static_cast<uint8_t>(x));
                    return packet;
                  }
                  //return std::vector<uint8_t>(); // Return empty vector if no condition matches(would still send a 0 lenght value because of heartbeatfilter)

      # - if: ######################ASCII version##############
      #     condition: ### Avoids filtration of Y over X axis messages and sending surplus LORA packets with zero when intending just Y axis.
      #       - lambda: |-
      #           auto usage = id(ble_hid_usage).state;
      #           //return usage id(lora_rf).state) == true && != "Y" && usage != "Rz";
      #           return id(lora_rf).state == true && usage != "Rz" && usage != "Y";          
      #     then:
      #       - sx1262.send_packet:
      #           # blocking: true
      #           data: !lambda |-
      #             static float last_2_196 = 0;
      #             static float last_2_197 = 0;
      #             static float last_x = 0;
      #             static float last_z = 0;
      #             if (id(ble_hid_usage).state == "X") {
      #               float v = ((x-32767.8)/32768)*10;
      #               if (std::abs(v - last_x) >= 0.7f) { //only send if value has change as much as 0.'n'f. Avoids flooding.
      #                 last_x = v;
      #                 char buf[32];
      #                 snprintf(buf, sizeof(buf), "A:3:%.2f", v);
      #                 std::string p = buf;
      #                 return std::vector<uint8_t>(p.begin(), p.end());
      #               }
      #             } else if (id(ble_hid_usage).state == "Z") {
      #               float v = ((x-32767.8)/32768)*10;
      #               if (std::abs(v - last_z) >= 0.7f) { //only send if value has change as much as 0.'n'f. Avoids flooding.
      #                 last_z = v;
      #                 char buf[32];
      #                 snprintf(buf, sizeof(buf), "A:5:%.2f", v);
      #                 std::string p = buf;
      #                 return std::vector<uint8_t>(p.begin(), p.end());
      #               }
      #             } else if (id(ble_hid_usage).state == "2_196") {
      #               float v = (x / 1023.0) * 1.0;
      #               if (std::abs(v - last_2_196) >= 0.8f) { //only send if value has change as much as 0.'n'f. Avoids flooding.
      #                 last_2_196 = v;
      #                 char buf[32];
      #                 snprintf(buf, sizeof(buf), "A:2:%.2f", v);
      #                 std::string p = buf;
      #                 return std::vector<uint8_t>(p.begin(), p.end());
      #               }
      #             } else if (id(ble_hid_usage).state == "2_197") { //only send if value has change as much as 0.'n'f. Avoids flooding.
      #               float v = (x / 1023.0) * 1.0;
      #               if (std::abs(v - last_2_197) >= 0.8f) {
      #                 last_2_197 = v;
      #                 char buf[32];
      #                 snprintf(buf, sizeof(buf), "A:1:%.2f", v);
      #                 std::string p = buf;
      #                 return std::vector<uint8_t>(p.begin(), p.end());
      #               }
      #             } else if (id(ble_hid_usage).state == "Record") {
      #               std::string p = ("B:17:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_14") {
      #               std::string p = ("B:6:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_15") {
      #               std::string p = ("B:7:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_7") {
      #               std::string p = ("B:8:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_8") {
      #               std::string p = ("B:9:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_11") {
      #               std::string p = ("B:4:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_12") {
      #               std::string p = ("B:5:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_1") {
      #               std::string p = ("B:12:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_2") {
      #               std::string p = ("B:13:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_4") {
      #               std::string p = ("B:14:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "9_5") {
      #               std::string p = ("B:15:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             } else if (id(ble_hid_usage).state == "Hat Switch") {
      #               std::string p = ("B:16:" + to_string(static_cast<int>(x)));
      #               return std::vector<uint8_t>(p.begin(), p.end());
      #             }
      #       - lambda: !lambda |-
      #           if (id(lora_tx_activity).state == false) {
      #             id(lora_tx_script).execute();
      #           }
         
    on_raw_value: ##normalized raw poll rate (no heartbeat), meaning button pressess may not be instant when transmited to LORA.
      - lambda: |-
            //if (!id(lora_tx_script).is_running()) {
            id(lora_tx_script).execute(); 
            //}      
      - if: ## XBOX HOME Button
          condition:
            - lambda: |-
                return id(ble_hid_usage).state == "9_13" && id(ble_hid_value).state == 1;
          then:
            - delay: 40ms
            # - ble_client.disconnect: ble_client_1             
            # - delay: 500ms
            - switch.turn_off: ble_hid_sw          
            - delay: 10s          
            - switch.turn_on: ble_hid_sw
            - delay: 5s
            - switch.turn_off: vext_ctrl  

      - if: ## XBOX Record button.
          condition:
            - lambda: |-
                return id(ble_hid_usage).state == "Record" && id(ble_hid_value).state == 1;  
          then:
            - delay: 50ms
            - switch.toggle: remote_mcu_wifi
            - delay: 100ms
            - switch.toggle: mcu_local_wifi

  - platform: adc 
    pin: GPIO1 ## Heltec V3 ADC gpio connected to batt. Onboard SH1.25-2 battery interface.##
    name: "MCU Battery Pack(HeltecV3)"
    id: mcu_battery
    icon: mdi:battery
    attenuation: 12db
    accuracy_decimals: 2
    update_interval: 10s
    samples: 10
    sampling_mode: avg
    web_server:
      sorting_group_id: sorting_group_mcu    
    filters:
      - multiply: 4.9
  
  - platform: internal_temperature
    name: "MCU Temperature"
    id: mcu_temperature
    icon: mdi:thermometer-lines
    web_server:
      sorting_group_id: sorting_group_mcu    
    filters:    
      - median:
          window_size: 10
          send_every: 15
          send_first_at: 1

  - platform: wifi_signal
    name: "MCU WIFI Signal"
    # update_interval: 15s
    icon: mdi:wifi
    web_server:
      sorting_group_id: sorting_group_mcu     
    filters:    
      - median:
          window_size: 10
          send_every: 15
          send_first_at: 1 

  - platform: sx1262 ## LORA ##
    rssi:
      id: lora_rssi
      name: Lora RSSI(local RX)
      icon:  mdi:video-input-antenna
      web_server:
        sorting_group_id: sorting_group_longrangeradio
        sorting_weight: 15
      filters:
         - median:
            window_size: 5
            send_every: 10
            send_first_at: 1            
    snr:
      id: lora_snr
      name: Lora SNR(local RX)
      icon:  mdi:video-input-antenna
      web_server:
        sorting_group_id: sorting_group_longrangeradio
        sorting_weight: 16
      filters:
        - median:
            window_size: 5
            send_every: 10
            send_first_at: 1       

  - platform: ble_client_hid ## BLE HID ##
    type: battery
    ble_client_hid_id: ble_client_hid_1
    name: "BLE HID Battery"
    id: ble_hid_batt
    entity_category: diagnostic
    icon: mdi:microsoft-xbox-controller-battery-charging
    web_server:
      sorting_group_id: sorting_group_bluetooth
  
  - platform: ble_client
    type: rssi
    ble_client_id: ble_client_1
    name: "BLE HID RSSI"
    id: ble_hid_rssi
    entity_category: diagnostic
    icon:  mdi:microsoft-xbox-controller    
    web_server:
      sorting_group_id: sorting_group_bluetooth

text_sensor:
  - platform: wifi_info
    ip_address:
      id: mcu_wifi_ip      
    ssid:
      id: mcu_wifi_ssid
      name: MCU WIFI SSID
      icon: mdi:wifi
      web_server:
        sorting_group_id: sorting_group_mcu

  - platform: uptime
    name: MCU UPtime
    web_server:
      sorting_group_id: sorting_group_mcu    
    format:
      separator: " "
      days: "D"
  
  - platform: ble_client_hid ## BLE HID USAGE (Buttons,Axis,Keypress indetifier)
    # name: "BLE HID Usage" ### Enable only as debug
    id: ble_hid_usage
    icon:  mdi:microsoft-xbox-controller
    web_server:
      sorting_group_id: sorting_group_robotcontrol
      sorting_weight: -1      

  - platform: template
    id: lora_rmt_rssi
    name: RMT RSSI(ping response)
    icon:  mdi:video-input-antenna
    on_value: 
      then:
        - logger.log:
            level: INFO
            format: "REMOTE RSSI telemetry recieved!"        
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 5      
    filters:
      - append: " dBm"    
  
  - platform: template
    id: lora_rmt_snr
    name: RMT SNR(ping response)
    icon:  mdi:video-input-antenna
    on_value: 
      then:
        - logger.log:
            level: INFO
            format: "REMOTE SNR telemetry recieved!"          
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 6
    filters:
      - append: " dB"    

output:
  - platform: ledc ### HeltecV3 Embeded LED
    id: mcu_led
    frequency: 2000    
    pin:
      number: GPIO35

light:
  - platform: monochromatic
    output: mcu_led
    id: lora_led
    # name: MCU LED
    icon: mdi:led-on
    default_transition_length: 0s
    effects:
      - pulse:
          name: "FastPulse"
          transition_length: 0.09s
          update_interval: 0.09s
          min_brightness: 0%
          max_brightness: 20%
      - pulse:
          name: "PacePulse"
          transition_length: 0.1s
          update_interval: 0.9s
          min_brightness: 0%
          max_brightness: 20%            
      - pulse:
          name: "FastPulseHi"
          transition_length: 0.01s
          update_interval: 0.1s
          min_brightness: 0%
          max_brightness: 100%  
      - pulse:
          name: "SlowPulseHi"
          transition_length: 0.01s
          update_interval: 0.8s
          min_brightness: 0%
          max_brightness: 100%               
      - pulse:
          name: "NotPulse"
          transition_length:
            on_length: 0.4s
            off_length: 500ms
      - strobe:

script:
  - id: lora_tx_script
    ## Scripts seems to result better for async states than using binary_sensor automations.....
    mode: restart                 
    then:
      - lambda: !lambda |-
          id(lora_tx_activity).publish_state(true);
      - script.execute: mcu_idle          
      - delay: 5.5s
      - lambda: !lambda |-
          id(lora_tx_activity).publish_state(false);
      - script.execute: mcu_idle
  
  - id: lora_rx_script
    ## Scripts seems to result better for async states than using binary_sensor automations.....
    mode: restart                 
    then:
      - lambda: !lambda |-
          id(lora_rx_activity).publish_state(true);       
      - delay: 5.5s
      - lambda: !lambda |-
          id(lora_rx_activity).publish_state(false);
  
  - id: uart_host_script
    ## Scripts seems to result better for async states than using binary_sensor automations.....
    mode: restart                 
    then:
      - lambda: !lambda |-
          id(uart_host_activity).publish_state(true);
      - script.execute: mcu_idle           
      - delay: 5.5s
      - lambda: !lambda |-
          id(uart_host_activity).publish_state(false);
  
  - id: mcu_idle
    ## Scripts seems to result better for async states than using binary_sensor automations.....
    mode: restart                 
    then:    
      - wait_until:
          all:
            - binary_sensor.is_off: lora_tx_activity
            # - binary_sensor.is_off: lora_rx_activity
            - binary_sensor.is_off: uart_host_activity
      - delay: 5min              
      - logger.log:
          level: INFO
          format: "LRTX has stayed INACTIVE for at least 5 minutes!"
      - switch.turn_off: vext_ctrl
       
number:          
  - platform: template 
    id: hud_servo
    name: HUD Servo(no control)
    icon: mdi:ship-wheel
    optimistic: True
    min_value: -1.0
    max_value: 1.0
    step: 0.1
    initial_value: 0.00
    mode: SLIDER
    restore_value: False
    update_interval: never  
    web_server:
      sorting_group_id: sorting_group_robotcontrol
    # on_value: 
    #   then:
    #     - sx1262.send_packet:
    #         # blocking: true
    #         data: !lambda |-
    #           std::string p = ("A:1:%.2f", to_string(x));
    #           return std::vector<uint8_t>(p.begin(), p.end());
            
  - platform: template 
    id: hud_throttle
    name: HUD Throttle(no control)
    # internal: True
    icon: mdi:ship-wheel
    optimistic: True
    min_value: 0.0
    max_value: 1.0
    step: 0.1
    initial_value: 0
    update_interval: never
    restore_value: False
    web_server:
      sorting_group_id: sorting_group_robotcontrol
  
  - platform: template 
    id: hud_reverse
    name: HUD Reverse(no control)
    # internal: True
    icon: mdi:ship-wheel
    optimistic: True
    min_value: 0.0
    max_value: 1.0
    step: 0.1
    initial_value: 0
    update_interval: never
    restore_value: False
    web_server:
      sorting_group_id: sorting_group_robotcontrol
      sorting_weight: 5
  
button:
  # - platform: template
  #   name: "Test UART Button 1"
  #   on_press:
  #     - uart.write: "2:33.33:44.44\r\n"
  # - platform: template
  #   name: "Test UART Button 2"
  #   on_press:
  #     - uart.write: "Hello World!!!\n"  
  - platform: restart
    name: 'MCU Restart'
    id: mcu_restart
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: -1
    icon: mdi:restart

  - platform: safe_mode
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 39
    name: 'MCU Restart Safe Mode'
  
  - platform: factory_reset
    entity_category: diagnostic
    name: "MCU Factory Reset"
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 40      
  - platform: shutdown
    name: "MCU SHUTDOWN"
    id: mcu_shutdown 
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 38        
  
  - platform: template ## LORA ##
    id: lora_ping
    name: Lora TX PING
    icon:  mdi:video-input-antenna      
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 4
    on_press:
      then:
        - delay: 20ms            
        - sx1262.send_packet:
            data: !lambda |-
              std::string s = "C:1:0"; //ping command
              id(lora_tx_script).execute();
              return std::vector<uint8_t>(s.begin(), s.end());
 
binary_sensor:
  - platform: template ## Triggered everytime PC host sends data thru serial and recieved by UART at USBC
    id: uart_host_activity
    name: USBC UART(activity)
    icon:  mdi:serial-port
    web_server:
      sorting_group_id: sorting_group_robotcontrol   
    on_press:
      then:
        - delay: 20ms
        - switch.turn_on: vext_ctrl        
        # - delay: 5.5s
        # - lambda: !lambda |-
        #    id(uart_host_activity).publish_state(false);     
  
  - platform: template
    id: lora_rx_activity
    name: Lora RX activity       
    icon:  mdi:video-input-antenna
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 14
    on_press:
      then:
        - lambda: |-
            if (!id(lora_led).current_values.is_on()) {
              id(lora_led).turn_on().set_effect("PacePulse").perform();
            }        
    on_release: 
      then:
        - delay: 500ms            
        - light.turn_off:
            id: lora_led           
            
  - platform: template
    id: lora_tx_activity
    name: Lora TX activity
    icon:  mdi:video-input-antenna
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 1
    on_press:
      then:
        - lambda: |-
            if (!id(lora_led).current_values.is_on()) {
              id(lora_led).turn_on().set_effect("FastPulse").perform();
            }        
    on_release: 
      then:
        - delay: 500ms
        - light.turn_off:
            id: lora_led                    
            
  - platform: template
    id: ble_hid_cx1
    name: BLE Controller (status)
    icon:  mdi:microsoft-xbox-controller
    web_server:
      sorting_group_id: sorting_group_robotcontrol
      sorting_weight: -1
    on_press: 
      then:
         - delay: 20ms             
         - switch.turn_on: vext_ctrl
         
  - platform: template
    id: remote_wifi_status
    name: Remote MCU WIFI(status)
    icon: mdi:wifi-cog
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 49  

  - platform: gpio
    # name: mcu_button
    id: mcu_button
    pin:
      number: GPIO0
      inverted: true
    on_multi_click:
      - timing:
          - ON for 40ms to 400ms
          - OFF for at least 330ms
        then:
          - logger.log:
              level: INFO
              format: "MCU Button SINGLE Clicked"
          - switch.toggle: vext_ctrl
          # - switch.turn_on: mcu_local_wifi

      - timing:
          - ON for 40ms to 400ms
          - OFF for 40ms to 300ms
          - ON for 40ms to 400ms
          - OFF for at least 330ms
        then:
          - delay: 50ms
          - logger.log:
              level: INFO
              format: "MCU Button DOUBLE Clicked"
          - switch.toggle: remote_mcu_wifi
          - delay: 100ms
          - switch.toggle: mcu_local_wifi


      - timing:
          - ON for 40ms to 400ms
          - OFF for 40ms to 300ms
          - ON for 40ms to 400ms
          - OFF for 40ms to 300ms
          - ON for 40ms to 340ms

        then:
          - logger.log:
              level: INFO
              format: "MCU Button TRIPLE Clicked"               
          # - button.press: mcu_restart
      
      # - timing:
      #     - ON for at least 550ms
      #         then:
      #     - while:
      #         condition:
      #           binary_sensor.is_on: push_button
      #         then:
                # - logger.log: "MCU Button Single Click Hold"
      - timing:
          - ON for at least 1.5s
        then:
          - while:
              condition:
                binary_sensor.is_on: mcu_button
              then:
                - logger.log: "MCU Button Single Click Hold"
      #           - script.stop: seg1
      #           # - light.turn_on:
      #           #     id: rgbw
      #           #     color_mode: RGB_WHITE
      #           #     red: 0%
      #           #     green: 100%
      #           #     blue: 0%
      #           #     # brightness: 40%
      #           #     color_brightness: 20%
      #           #     white: 0%
      #           #     # effect: "Fast Pulse"
      #           - script.execute: seg2   
      #           - delay: 18s ## time in ms before resend                
      # - timing:
      #     - ON for at least 3s
      
      #   then:
      #     - while:
      #         condition:
      #           binary_sensor.is_on: push_button
      #         then:
      #           # - logger.log: "hold3"
      #           - script.stop: seg2
      #           # - light.turn_on:
      #           #     id: rgbw
      #           #     color_mode: RGB_WHITE
      #           #     red: 0%
      #           #     green: 100%
      #           #     blue: 0%
      #           #     # brightness: 40%
      #           #     color_brightness: 20%
      #           #     white: 0%
      #           #     # effect: "Fast Pulse"
      #           - script.execute: seg3   
      #           - delay: 8s ## time in ms before resend 

      # - timing:
      #     - ON for 40ms to 400ms
      #     - OFF for 40ms to 300ms
      #     - ON for at least 550ms
      #     # - OFF for at least 330ms
      #   then:
      #     - while:
      #         condition:
      #           binary_sensor.is_on: push_button
      #         then:
      #           # - media_player.volume_down
      #           # - logger.log: "Double HOLD"                  
      #           - delay: 1500ms ## time in ms before resend
switch:
  - platform: gpio
    id: vext_ctrl
    name: OLED power (HeltecV3) #### Heltec V3 external power which will also power the OLED display.Vext Pin 
    icon: mdi:lightning-bolt
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 20
    pin:
      number: GPIO36
      inverted: True
    restore_mode: ALWAYS_ON
    on_turn_on: 
      then:
        - component.resume: my_display        
        - delay: 50ms            
        - switch.turn_on: batt_div
    #     - delay: 1min
    #     - switch.turn_off: vext_ctrl
    on_turn_off: 
      then:
        - delay: 50ms
        - switch.turn_off: batt_div
        - component.suspend: my_display
       
  - platform: gpio
    id: batt_div
    name: Batt Divider circuit (HeltecV3) ## Heltec V3 Battery Voltage divider circuit. On high enables to READ from ADC GPIO0 ##
    icon: mdi:battery-sync-outline
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 21            
    pin:
      number: GPIO37
    restore_mode: ALWAYS_OFF

  - platform: template ## LORA software defined block, inhibits sending messages whenever implemented...
    optimistic: True
    id: lora_rf
    name: Lora RF(RADIO SILENCE)
    restore_mode: ALWAYS_ON
    icon:  mdi:video-input-antenna        
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 7
    # on_turn_off: 
    #   then:
    #     - sx1262.sleep

  - platform: template ## LOCAL Control to allow disallow BLE controller to connect.
    name: BLE HID
    id: ble_hid_sw
    icon: mdi:bluetooth
    optimistic: True
    restore_mode: ALWAYS_ON
    web_server:
      sorting_group_id: sorting_group_bluetooth
    turn_on_action:
      - delay: 1s
      - esp32_ble_tracker.start_scan:
          continuous: true
    turn_off_action:
      - esp32_ble_tracker.stop_scan:
      - delay: 1s
      - ble_client.disconnect: ble_client_1

  
  - platform: template ## LOCAL WIFI control ##
    id: mcu_local_wifi
    name: MCU Local WIFI
    restore_mode: ALWAYS_ON
    optimistic: True
    icon: mdi:wifi
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 29        
    on_turn_on:
      then:
        - logger.log: 
            level: INFO
            format: "LOCAL WIFI Turned ON!!!"         
        - delay: 1s
        - lambda: !lambda |-
            wifi::global_wifi_component->enable();
            
    on_turn_off:
      then:
        - logger.log: 
            level: INFO
            format: "LOCAL WIFI Turned OFF!!!"         
        - delay: 1s
        - lambda: !lambda |-
            wifi::global_wifi_component->disable();
       
  
  - platform: template ## REMOTE WIFI control ##
    id: remote_mcu_wifi
    name: Remote MCU WIFI(async trigger)
    restore_mode: ALWAYS_ON
    optimistic: True
    icon: mdi:wifi-cog
    web_server:
      sorting_group_id: sorting_group_longrangeradio
      sorting_weight: 50        
    on_turn_on:
      then:   
        - delay: 20ms
        - sx1262.send_packet:
            data: !lambda |-
              std::string s = "C:0:1";
              id(lora_tx_script).execute();
              return std::vector<uint8_t>(s.begin(), s.end());
        - delay: 500ms
        - script.execute: lora_tx_script        
        - sx1262.send_packet:
            data: !lambda |-
              std::string s = "C:0:1";
              return std::vector<uint8_t>(s.begin(), s.end());              
    on_turn_off: 
       then:   
        - delay: 20ms
        - script.execute: lora_tx_script
        - sx1262.send_packet:
            data: !lambda |-
              std::string s = "C:0:0";
              id(lora_tx_script).execute();
              return std::vector<uint8_t>(s.begin(), s.end());
        - delay: 500ms
        - sx1262.send_packet:
            data: !lambda |-
              std::string s = "C:0:0";
              return std::vector<uint8_t>(s.begin(), s.end());                    

sx1262:  ## LORA ## https://github.com/christianhubmann/esphome_component_sx1262
# Region Code	Description	Frequency Range (MHz)	Duty Cycle (%)	Power Limit (dBm) ###https://www.thethingsnetwork.org/docs/lorawan/regional-parameters/eu868/
# US	United States	902.0 - 928.0              	100	30
# EU_433	European Union 433MHz	433.0 - 434.0	  10	12
# EU_868	European Union 868MHz	869.4 - 869.65	10	27
# CN	China	470.0 - 510.0	                      100	19
# JP	Japan	920.8 - 927.8	                      100	16
# ANZ	Australia & New Zealand	915.0 - 928.0	    100	30
# KR	Korea	920.0 - 923.0	                      100	
# TW	Taiwan	920.0 - 925.0	                    100	27
# RU	Russia	868.7 - 869.2	                    100	20
# IN	India	865.0 - 867.0	                      100	30
# NZ_865	New Zealand 865MHz	864.0 - 868.0	    100	36
# TH	Thailand	920.0 - 925.0	                  100	16
# UA_433	Ukraine 433MHz	433.0 - 434.7	        10	10
# UA_868	Ukraine 868MHz	868.0 - 868.6	         1	14
# MY_433	Malaysia 433MHz	433.0 - 435.0	        100	20
# MY_919	Malaysia 919MHz	919.0 - 924.0	        100	27
# SG_923	Singapore 923MHz	917.0 - 925.0	      100	20       
  id: lora 
  clk_pin: 9
  mosi_pin: 10
  miso_pin: 11
  cs_pin: 8
  irq_pin: 14
  reset_pin: 12
  busy_pin: 13
  frequency: 904.2 ####In the US, Z-Wave devices typically operate in the 908.42 MHz and 916 MHz frequency bands. For Z-Wave Long Range, the frequency bands are 912 MHz and 920 MHz 
  # frequency: 869.2
  # frequency: 
  sync_word: 0xf7 ## (Optional): The sync word. Defaults to 0x12 // sync word:   0x34 (public network/LoRaWAN)
  bandwidth: 500.0 ###(Optional): The bandwidth in kHz. One of 125.0 (default), 250.0 and 500.0                                                                                                
  tx_power: -6 ### (Optional): The TX output power in dBm. Defaults to 10 
  coding_rate: 8 ##The coding rate. One of 5 for 4/5, 6 for 4/6, 7 (default) for 4/7 and 8 for 4/8.
  preamble_length: 10  ##(Optional): The preamble length. Defaults to 8 
  spreading_factor: 8  ##The spreading factor. Allowed values are between 7 and 12. Defaults to 9. Larger spreading factors mean larger processing gain, and so a signal modulated with a larger spreading factor can be received with less errors compared to a signal with a lower spreading factor, and therefore travel a longer distance. For example, a signal modulated with the SF12 can travel a longer distance than a signal modulated with the SF7.
  data_rate: 80MHz ###Set the data rate of the controller. One of 80MHz, 40MHz, 20MHz, 10MHz, 5MHz, 4MHz, 2MHz, 1MHz (default), 200kHz, 75kHz or 1kHz.
  ##Spread Factor and Bandwidth:
  ##LoRa data rates are determined by the spreading factor (SF) and bandwidth.
  ## Lower SF and higher bandwidth result in faster data rates,
  ## while higher SF and lower bandwidth lead to slower data rates.
  ## For example, using SF7 and a 62.5 kHz bandwidth results in a data rate of 2734 bps.
  on_packet_receive:
  #   - logger.log:
  #       level: INFO
  #       format: "Received message: %s"
  #       args: [ 'std::string(data.begin(), data.end()).c_str()' ]
    - lambda: |-
          if (!id(lora_rx_script).is_running()) {
              id(lora_rx_script).execute(); 
          }  
    - lambda: |-
        //DECODE to ASCII
        std::string dstream(data.begin(), data.end());
        // Map patterns to their corresponding actions
        struct PatternAction {
          int offset;
          std::function<void(const std::string&)> action;
        };
        const std::map<std::string, PatternAction> pattern_map = {
          //###Remote telemtry####
          {"C:0:", {4, [](const std::string& s){ id(remote_wifi_status).publish_state(atof(s.c_str())); }}}, //ping feedback remote wifi state
          {"C:1:1:", {6, [](const std::string& s){ id(lora_rmt_rssi).publish_state(s.c_str()); }}}, //ping feedback from RMT LORA rssi
          {"C:1:2:", {6, [](const std::string& s){ id(lora_rmt_snr).publish_state(s.c_str()); }}} //ping feedback RMT LORA snr
        };
        for (const auto& [pat, act] : pattern_map) {
          auto pos = dstream.find(pat);
          if (pos != std::string::npos) {
            std::string modified = dstream.substr(pos + act.offset);
            act.action(modified);
            break;
          }
        } 

select:
  - platform: logger
    id: logger_select
    web_server:
      sorting_group_id: sorting_group_mcu
      sorting_weight: 30  
    name: Logger Level
    entity_category: diagnostic
font:
  - file: "gfonts://Roboto"
    id: roboto_14
    size: 14
  - file: "gfonts://Roboto"
    id: roboto_10
    size: 10
  - file: "gfonts://Roboto"
    id: roboto_9
    size: 9    

image:
  - file: mdi:video-input-antenna
    id: lora_ant
    type: binary
    resize: 18x18
  - file: mdi:sync-off
    id: lora_ant_off
    type: binary
    resize: 18x18

  - file: mdi:serial-port
    id: serial_off
    type: binary
    resize: 18x18
  - file: mdi:serial-port
    id: serial
    type: binary
    resize: 18x18    
    invert_alpha: True
  - file: mdi:thermometer
    id: mcu_temp
    type: binary
    resize: 13x13
  - file: mdi:battery-high
    id: batt_on
    type: binary
    resize: 13x13
       
  - file: mdi:download
    id: lora_rx_off
    type: binary
    resize: 25x25
  - file: mdi:download-circle
    id: lora_rx
    type: binary
    resize: 25x25  
  
  - file: mdi:upload
    id: lora_tx_off
    type: binary
    resize: 25x25 
  - file: mdi:upload-circle
    id: lora_tx
    type: binary
    resize: 25x25 
  
  - file: mdi:bluetooth
    id: bt
    type: binary
    resize: 15x15
    invert_alpha: True    
  - file: mdi:bluetooth-off
    id: bt_off
    type: binary
    resize: 13x13


  - file: mdi:microsoft-xbox-controller-battery-charging
    id: controller
    type: binary
    resize: 17x17
  - file: mdi:microsoft-xbox-controller-off
    id: controller_off
    type: binary
    resize: 17x17    
  
  - file: mdi:wifi
    id: wifi_on
    type: binary
    resize: 13x13         
  - file: mdi:wifi-strength-off-outline
    id: wifi_off
    type: binary
    resize: 13x13
  - file: mdi:wifi-cog
    id: rmt_wifi_on
    type: binary
    resize: 14x14
  - file: mdi:wifi-strength-alert-outline
    id: rmt_wifi_off
    type: binary
    resize: 14x14             

display:
  - platform: ssd1306_i2c
    id: my_display
    model: "SSD1306 128x64"
    reset_pin: GPIO21
    i2c_id: bus_a
    update_interval: 0.7s
    rotation: 90
    address: 0x3C
    lambda: |-  
      it.line(0, 24, 65, 24);
      it.line(0, 40, 64, 40);
      it.line(0, 59, 45, 59);
      it.line(0, 73, 65, 73);
      it.line(0, 89, 65, 89);
      it.line(0, 109, 65, 109);
      //LORA telemetry
      if (id(lora_tx_activity).state) {
        it.image(-1, -1, id(lora_tx));
      } else {
        it.image(-1, -1, id(lora_tx_off)); 
      }
      if (id(lora_rx_activity).state) {
        it.image(40, -1, id(lora_rx));
      } else {
        it.image(40, -1, id(lora_rx_off));
      }
      if (id(lora_rf).state) {
        it.image(23, -1, id(lora_ant));
      } else {
        it.image(23, -1, id(lora_ant_off));
      }                  
      if (!id(lora_rssi).state == 0) {
        it.printf(0, 26, id(roboto_9), "rssi %.0f%", (id(lora_rssi).state));
        it.printf(33, 26, id(roboto_9), "snr %.0f%", (id(lora_snr).state));
      } //else {
        //it.image(12, 25, id(controller_off));
        //it.printf(27, 27, id(roboto_10), "NoCtrller");
      //}           

      //BLE HID
      if (id(ble_hid_sw).state) {
        it.image(-1, 43, id(bt));
      } else {
        it.image(-1, 43, id(bt_off));
      }    
      if (id(ble_hid_cx1).state) {
        it.image(12, 42, id(controller));
        it.printf(29, 43, id(roboto_10), "%.0f%%", (id(ble_hid_batt).state));
      } else {
        it.image(12, 42, id(controller_off));
        //it.printf(27, 43, id(roboto_10), "NoCtrller");
      }           
      //UART PC Host Activity
      if (id(uart_host_activity).state) {
        it.printf(0, 59, id(roboto_10), "ACTIVE");
        it.image(47, 51, id(serial));
      } else {
        it.printf(0, 59, id(roboto_10), "INACTIVE");
        it.image(47, 51, id(serial_off));
      }         

      //Remote WIFI nodes
      if (id(remote_wifi_status).state) {
        it.image(-2, 74, id(rmt_wifi_on));
        it.printf(12, 76, id(roboto_9), "RmtWIFI ON");
      } else {
        it.image(-2, 74, id(rmt_wifi_off));
        it.printf(12, 76, id(roboto_9), "RmtWIFI OFF");
      }

      // MCU telemetry
      if (id(mcu_temperature).state) {
        it.image(-3, 92, id(mcu_temp));
        it.printf(7, 92, id(roboto_10), "%.0fÂ°C", (id(mcu_temperature).state));
        it.image(29, 92, id(batt_on));
        it.printf(42, 92, id(roboto_10), "%.1fV", (id(mcu_battery).state));                
      }      
      //Local WIFI
      if (id(mcu_local_wifi).state) {
        it.image(-2, 111, id(wifi_on));
        it.printf(15, 109, id(roboto_10), "%s", (id(mcu_wifi_ssid).state).c_str());
        it.printf(5, 119, id(roboto_9), "%s", (id(mcu_wifi_ip).state).c_str());
      } else {
        it.image(-2, 111, id(wifi_off));
        it.printf(15, 112, id(roboto_10), "Wifi OFF");
      }         